<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8">
		<title>JS : listeners</title>
		<meta name="author" content="Alexandre Venet">
		<meta name="description" content="Les écouteurs d'événement en Javascript.">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
		<link rel="stylesheet" href="../css/styles.css">
	</head>
	<body>

		<header>
			<div class="conteneur">
				<a href="https://alexandrevenet.github.io" title="Alexandre Venet sur GitHub">alexandrevenet.github.io</a>
			</div>
		</header>

		<main>
			<div class="conteneur">
				<section>
					<h1>JS : listeners</h1>
					<p class="couleurGris">Note sur les écouteurs d'événement en Javascript.</p>
				</section>
				<section>
					<h2>On[event]</h2>
					<p>On peut <strong>ajouter</strong> un événement avec la méthode <code>on[event]</code> qui inscrit l'attribut correspondant dans la balise cible. Cette méthode traite <strong>un seul gestionnaire</strong>, ce qui permet des <strong>remplacements</strong>, mais <strong>exclut tout ajout ultérieur</strong> d'écouteur pour le même événement. Exemple avec fonction anonyme :</p>
					<pre><code>
el.onclick = function(){ // ajoute à el l'attribut onclick
	console.log('Click sur el');
};
					</code></pre>
					<p>On peut "<strong>retirer</strong>" un écouteur de ce type de plusieurs manières :</p>
					<pre><code>
el1.onclick = ()=&gt;{ return false; } // retourner une chose sans incidence
el2.onclick = ()=&gt;{ return null; } // idem
el3.removeAttribute('onclick'); // supprimer l'attribut de la balise
el4.onclick = ''; // modifier le gestionnaire
					</code></pre>
				</section>
				<section>
					<h2>addEventListener()</h2>
					<p><strong>Ajouter</strong> un événement peut se faire également avec <code>addEventListener()</code> qui permet des <strong>ajouts ultérieurs</strong> pour le <strong>même événement</strong>. Exemples avec fonctions fléchées anonymes :</p>
					<pre><code>
el.addEventListener('click',()=&gt;{
	console.log('un');
}
el.addEventListener('click',()=&gt;{
	console.log('deux');
}
// affiche les deux strings dans la console
					</code></pre>
					<p><strong>Retirer</strong> ce type d'événement s'effectue avec <code>removeEventListener()</code>. Exemple avec fonction extérieure :</p>
					<pre><code>
el.addEventListener('click', funk);
el.removeEventListener('click', funk);
					</code></pre>
				</section>
				<section>
					<h2>addEventListener(), bind() et removeEventListener()</h2>
					<p><strong>Retirer</strong> l'écouteur ajouté avec <code>addEventListener()</code> peut poser problème lorsqu'on utilise <code>bind()</code>. En effet, cela <strong>renvoie une nouvelle fonction</strong> ; donc, il n'y a <strong>pas de référence unique</strong> à cette fonction.</p>
					<pre><code>
function funk () { console.log('funk !'); }
el.addEventListener('click', funk.bind());
el.removeEventListener('click', funk.bind());
// ne fonctionne pas car funk.bind() renvoie chaque fois une nouvelle fonction
					</code></pre>
					<p>On résout ce problème avec une déclaration de <strong>variable</strong>, unique référence vers laquelle pointent les écouteurs et qui pointe elle-même de façon unique sur la fonction.</p>
					<pre><code>
function funk () { console.log('funk !'); } // fonction
let ref = funk.bind(); // référence
el.addEventListener('click', ref);
el.removeEventListener('click', ref);
// fonctionne car n'est pointée qu'une seule référence
					</code></pre>
					<p>Cela fonctionne aussi en POO en passant le <code>this</code> de l'objet :</p>
					<pre><code>
dire(){ console.log('Bonjour !'); } // fonction
const ref = this.dire.bind(this); // référence
el.addEventListener('click',ref);
el.removeEventListener('click',ref);
					</code></pre>
				</section>
			</div>
		</main>

		<footer>
		</footer>

	</body>
</html>
