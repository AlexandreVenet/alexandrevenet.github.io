<section>
	<h1>Post-processing stack</h1>
	<a class="lien" title="Manual : overview" target="_blank" href="https://docs.unity3d.com/Manual/PostProcessingOverview.html">Manual : overview</a>
	<a class="lien" title="Manual : integration" target="_blank" href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/integration-with-post-processing.html">Manual : integration</a>
	<div class="blocSommaire">
		<p>Sommaire</p>
		<ol id="sommaire">
			<li><a href="#parametrage">Paramétrage</a></li>
			<li><a href="#effets">Effets</a></li>
		</ol>
	</div>
</section>
<section id="parametrage">
	<h2>Paramétrage</h2>
	<p>On peut ajouter des effets de <i><strong>post-processing</strong></i> à la caméra :  effets visuels ajoutés en fin de calcul de <i>frame</i> pour obtenir un certain rendu.</p>
	<ul>
		<li>Ouvrir le <code>Window &gt; Package manager</code>.</li>
		<li>Choisir <code>Unity Registry</code>.</li>
		<li>Chercher <code>Post Processing</code>.</li>
		<li>Installer.</li>
	</ul>
	<p>Dans la fenêtre <code>Project</code>, faire clic droit puis <code>Create &gt; Post-processing Profile</code>. C'est le fichier  qui contient toutes les données d'effets que l'on va ajouter.</p>
	<p>Créer un objet dans la scène et lui attacher le composant <code>Post-Process Volume</code>. On peut aussi attacher ce composant à la caméra mais en faire un <strong>objet dédié</strong> a des avantages :</p>
	<ul>
		<li>si on change de caméra au cours de l'application, nul besoin d'ajouter un composant à cette nouvelle caméra ; ainsi <strong>les paramètres sont conservés</strong>,</li>
		<li>cela autorise <strong>plusieurs <i>post process</i></strong>, par exemple : utiliser un objet dédié pour un espace extérieur et un autre pour un espace intérieur, la transition étant codée (comme en <i>IK</i>) avec la propriété <code>Weight</code> (le poids d'un <code>post-process volume</code> modifiable pour effectuer des transitions).</li>
	</ul>
	<p>Attribuer à cet objet un <i><strong>Layer</strong></i> nommé « <i>PostProcess</i> » (ou autre). C'est par ce <i>layer</i> que la caméra va afficher les effets ; sans lui, pas d'effet.</p>
	<p>Y renseigner dans le champ <code>Profile</code> le fichier profil précédemment créé. Si le fichier n'existe pas, on peut cliquer sur <code>New</code> pour en créer un ; alors le fichier est créé dans un dossier du nom de la scène avec le suffixe <code>_Profiles</code>.</p>
	<p>Sélectionner la caméra, lui attacher un composant <code>Post-Process Layer</code>. Au paramètre <code>Layer</code>, choisir « <i>PostProcess</i> ».</p>
	<p>On peut commencer à paramétrer le composant <code>Post-Process Volume</code>.</p>
	<p>La case <code>Is Global</code> applique les <strong>effets à toute caméra de la scène</strong>.</p>
</section>
<section id="effets">
	<h2>Effets</h2>
	<p>On dispose maintenant d'une batterie d'effets à ajouter avec le bouton <code>Add effect...</code>.</p>
	<p>Tous ces effets sont autant de calculs en plus pour rendre l'image à l'écran. Certains effets sont peu coûteux en calcul (vignette, distorsion de lentille) car ils prennent peu d'informations de la scène pour être effectués. En revanche, tous les effets sont <strong>superposables</strong>, ce qui a un coût en termes de calcul <strong>en plus</strong> du calcul de chaque effet.</p>
	<p>Le bouton <code>On/Off</code> gère le paramètre d’<strong>activité</strong>. Ne pas confondre avec l’activité du <strong>composant</strong> d’effet contrôlée par la case à cocher à côté du nom.</p>
	<ul>
		<li><code>Vignette</code> permet d'ajouter un filtre autour du centre de l'image pour concentrer l'attention,</li>
		<li><code>Bloom</code> ajoute des éblouissements sur les matériaux avec émission ou <i>specular highlights</i>,</li>
		<li><code>Lens distorsion</code> : effets de lentille comme par exemple le <i>fish-eye</i>,</li>
		<li><code>Motion blur</code> : plus efficace en rotation qu’en translation, gourmand en calcul car dépend du mouvement de caméra,</li>
		<li><code>Depth of field</code> : avec une <code>Aperture</code> petite et une <code>Length</code> grande la modification de la <code>Focus distance</code> est plus aisée le point de netteté est visible,</li>
		<li><code>Auto exposure</code> : gestion automatique de l’éblouissement ou de l'obscurcissement lors du passage d'une zone éclaire à une zone d'ombre et inversement,</li>
		<li><code>Chromatic aberration</code> : décalage des couleurs (à coupler éventuellement avec la distorsion de lentille),</li>
		<li><code>Color grading</code> : modification des couleurs. Il nécessite un <strong>espace de couleurs linéaire</strong> qui est plus réaliste et plus lourd en calculs que le <strong>gamma</strong>. Pour cela, aller dans menu <code>Edit &gt; Project settings &gt; Player &gt; Other settings &gt; Color space</code>. Ensuite, paramétrer le composant à loisir. Pour les <i>trackballs</i>, tout est déplaçable avec clic gauche souris, et le clic droit réinitialise les valeurs : <code>Lift</code> pour les tons sombres, <code>Gamma</code> pour les tons moyens, <code>Gain</code> pour les tons clairs,</li>
		<li><code>Ambiant occlusion</code> : ombres dans les angles moins éclairés. Les objets peuvent avoir une texture au paramètre <code>Occlusion</code>, texture qui contrôle en niveau de gris comment l’effet doit s’appliquer,</li>
		<li><code>Screen space reflections</code> : réclame une caméra en <code>Rendering path</code> : <code>Deferred</code>. Simule des réflexions en inversant le rendu. Limite : un objet non vu par la caméra n’est pas calculé.</li>
		</ul>
		<p>Tous ces effets sont ceux d'Unity mais il existe de nombreux autres disponibles selon le <i>Render pipeline</i> utilisé ou sur Internet.</p>
</section>
<footer>
	<p>Le 12-04-2021</p>
</footer>
<script src="../../js/testParent.js"></script>
