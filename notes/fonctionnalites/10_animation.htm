<section>
	<h1>Animation</h1>
	<p>Documentation officielle : </p>
	<a class="lien" href="https://docs.unity3d.com/ScriptReference/Animator.html" target="_blank" title="Animator">Animator</a>
	<div class="blocSommaire">
		<p>Sommaire</p>
		<ol id="sommaire">
			<li><a href="#creer">Créer une animation</a></li>
			<li><a href="#controller">Animation controller</a></li>
			<li><a href="#code">Côté code</a></li>
			<li><a href="#blendtree">Blend tree</a></li>
			<li><a href="#event">Animation event</a></li>
			<li><a href="#personnage"></a>Personnage</li>
			<li><a href="#timeline">Timeline</a></li>
		</ol>
	</div>
</section>
<section id="creer">
	<h2>Créer une animation</h2>
	<p>On peut créer une animation de bien des façons, en voici une procédure :</p>
	<ul>
		<li>sélectionner un <code>gameObject</code> qui sert de support à l'animation (il aura un composant <code>Animator</code>). Comment choisir cet objet ? Parce qu'il est celui que l'on veut animer ou parce qu'il contient des objets enfants que l'on veut animer,</li>
		<li>ouvrir la fenêtre <code>Window > Animation > Animation</code>. Cliquer sur <code>Create</code>. Enregistrer un nouveau fichier <code>Animation clip</code>,</li>
		<li>la <i>Timeline</i> devient disponible. On réalise l'animation en appuyant sur le bouton rouge <code>Record</code> ou bien en modifiant une propriété que l'on choisit en cliquant sur le bouton <code>Add Property</code>. Toute modification dans Unity sera représentée dans la <i>timeline</i> par une propriété et des <i>keyframes</i>,</li>
		<li>une autre représentation consiste en des courbes de Bézier où l'animation dans les intervalles entre <i>keyframes</i> (pour ajuster la fenêtre, tout sélectionner puis taper la touche <code>F</code>),</li>
		<li>si l'objet support ne l'a pas déjà, Unity lui attache le composant <code>Animator</code>.</li>
	</ul>
	<p>Une animation doit avoir <strong>au moins 1 <i>keyframe</i></strong> enregistrant la propriété à animer ; sinon, rien n’est animé.</p>
	<p><strong>L’animation verrouille les propriétés animées</strong>. Donc, impossible de modifier ces valeurs par code dans le même temps que l’animation. Si on utilise <code>Animator</code>, alors il faut changer d’état pour ensuite faire quoi que ce soit.</p>
	<p>Un fichier d'animation a des propriétés : sélectionner le fichier pour les exposer en <code>Inspector</code>.</p>
</section>
<section id="controller">
	<h2>Animation controller</h2>
	<p>Le composant <code>Animator</code> est attaché à un objet et réfère à un <strong><i>Animation Controller</i></strong>. Ce contrôleur d'animation est un fichier (<i>asset</i>) spécifique gérant l'animation. On y accède par la fenêtre <code>Project</code> ou le champ <code>Controller</code> du composant ; double-cliquer sur ce champ ouvre la fenêtre <code>Animator</code>.</p>
	<p>L'<i>animation controller</i> implémente le <i>design pattern</i> <strong><i>State Machine</i></strong> et la fenêtre <code>Animator</code> en fournit une représentation graphique. On y trouve : </p>
	<ul>
		<li>des <strong>couches</strong> d'animation (<i>layers</i>), chacune présentant un <strong>diagramme</strong> d'<strong>états</strong> (<i>states</i>) reliés par des <strong>transitions à conditions de passage</strong>,</li>
		<li>des <strong>paramètres</strong> servant aux <strong>conditions de passage</strong> d'un état à un autre.</li>
	</ul>
	<p>La fenêtre <code>Animator</code> est mise à jour en mode <code>Game</code>, ce qui permet de suivre les changements en temps réel.</p>
	<p>Chaque <strong>état</strong> correspond à un fichier d'animation spécifique et est un bouton :</p>
	<ul>
		<li><strong>simple clic</strong> : des infos de l'<strong>état</strong>, comme la vitesse (<i>speed</i>) à la quelle jouer l'animation sélectionnée,</li>
		<li><strong>double clic</strong> : des infos sur le <strong>fichier</strong> d'animation, avec prévisualisation si appliquable,</li>
		<li><strong>clic droit</strong> : options de contrôle.</li>
	</ul>
	<p>Un bouton vert <code>Entry</code> représente <strong>l'état au démarrage</strong> ; ce bouton vert est lié à un bouton d'état. Avec un clic droit sur un bouton, choisir <code>Set as layer default state</code> pour lier un autre état au lancement.</p>
	<p>Chaque <strong>transition</strong> fait l'objet d'un <strong>lien fléché</strong> : </p>
	<ul>
		<li><strong>simple clic</strong> ouvre les paramètres en <code>Inspector</code> :
			<ul>
				<li><code>Has Exit Time</code> coché pour passer automatiquement ou non à l'animation suivante (décocher pour contrôler seulement par conditions),</li>
				<li>la <i>timeline</i> de transition mesurée en <strong>secondes</strong>,</li>
				<li>le <strong>PETIT</strong> bouton <code>Settings</code> juste au-dessus où on peut paraméter l'<code>Exit time</code> (quand sortir de la <i>frame</i>) et la <code>Transition duration</code> (durée de la transition),</li>
				<li>les <strong>conditions</strong> de changement d'état : cliquer sur <code>+</code> pour en ajouter,</li>
			</ul>
		</li>
		<li><strong>clic droit</strong> : options de contrôle.</li>
	</ul>
	<p>Les <code>Parameters</code> sont des <strong>variables</strong> : <code>float</code>, <code>bool</code>, <code>int</code> et le spécial <code>trigger</code> (<i>on/off</i>, déclenché à l'appel). Ces variables servent de paramètres aux <strong>conditions de passage</strong>. On peut créer par exemple un paramètre <code>SpeedX</code> qui sert de condition de transition entre des états <code>Idle</code> et <code>Walk</code>. Si par exemple, on modifie ce paramètre à 0.3, alors dans la transition la condition sera testée (par exemple <code>SpeedX Greater 0.1</code>) et le personnage passera automatiquement de <code>Idle</code> à <code>Walk</code>. Lorsqu'il y a plusieurs conditions (plusieurs paramètres sont utilisés) pour une même transition, Unity gère ces conditions en ET logique.</p>
	<p>On peut ajouter <strong>plusieurs transitions entre deux états</strong>. La flèche possède alors trois triangles. Ajouter une transition génère à chaque fois un jeu de conditions et chaque transition apparaît dans la liste en haut de l'<code>Inspector</code>. Unity gère ces conditions en OU logique.</p>
</section>
<section id="code">
	<h2>Côté code</h2>
	<p>En C#, on d'abord a besoin de référer au composant <code>Animator</code>. Pour cela, renseigner un champ sérialisé ou récupérer le composant dans <code>Awake()</code>. Par exemple, imaginons un objet <code>Player</code> ayant un enfant <code>Graphics</code> qui a le composant <code>Animator</code> (cet enfant contient des enfants animés), et codons un composant script de <code>Player</code> :</p>
	<pre><code>
Animator _animator;
void Awake()
{
	_animator = transform.Find("Graphics").GetComponent&lt;Animator&gt;();
}
	</code></pre>
	<p>Pour modifier les paramètres en C# et déclencher des transitions :</p>
	<ul>
		<li><code>SetTrigger()</code> : activer (<i>on/off)</i>,</li>
		<li><code>SetBool("nom", true)</code> : assignation de valeur booléenne,</li>
		<li><code>SetInteger("nom", 1)</code> : assignation de valeur de nombre entier,</li>
		<li><code>SetFloat("nom",0.5f)</code> : assignation de valeur à virgule flottante.</li>
	</ul>
	<p>Pour gérer les transitions avec <code>GetAxis</code>, il faut utiliser une valeur absolue car <code>GetAxis</code> renvoie des valeurs comprises entre [-1,1] alors que par exemple <code>SetFloat()</code> utilise des valeurs entre [0,1].</p>
	<pre><code>
float horizontal = Input.GetAxis("Horizontal");
_animator.SetFloat("SpeedX", Mathf.Abs(horizontal));
	</code></pre>
	<p>Pour aller à un état directement, on fait référence au <code>Layer</code> d'animation. On peut également indiquer le temps (normalisé de 0 à 1) à partir duquel jouer :</p>
	<pre><code>
_animator.Play("Base Layer.NomEtat", 0, 0f);
	</code></pre>
</section>
<section id="blendtree">
	<h2>Blend tree</h2>
	<p>Les <strong><i>Blend Trees</i></strong> servent à regrouper des animations quand ces animations font partie d'un <strong>même ensemble</strong> et sont liées aux <strong>mêmes paramètres</strong>. Les <i>blend trees</i> ne fonctionnent qu'avec des <code>float</code> car les transitions y sont <strong>calculées relativement aux paramètres</strong> et non plus en temps comme les transitions standard.</p>
	<p>Par exemple : en 2D avec <i>scrolling</i> de côté, les animations <code>Idle</code>, <code>Walk</code> et <code>Run</code> ont en commun d'être des animations de locomotion sur l'axe des x. Mais rien ne lie <code>Walk</code> et <code>Jump</code> ou <code>Attack</code>.</p>
	<p>Pour créer un <i>blend tree</i> : clic droit dans un diagramme d'<code>Animator</code> puis <code>Create State > From New Blend Tree</code>. Puis double cliquer dessus.</p>
	<p>Par défaut, les <i>blend trees</i> sont à une dimension (1D) mais on peut en faire à plusieurs dimensions. Par exemple, <code>2D Freeform Directional</code> permet de poser un état central (0,0) et des états distribués en cercle tout autour.</p>
	<p>Sélectionner le(s) paramètre(s) dans le menu déroulant contrôlant la transition. Et ajouter un ou plusieurs <code>Motion</code>, c'est-à-dire des animations. On peut en ajouter tant qu’elles ont toutes le même rapport et sont relatives au même paramètre, sinon le rendu risque d'étonner.</p>
	<p>Exemple d'animation 2D de l'état <code>Idle</code> d'un personnage vu de dessus et qui possède 8 positions relatives au <i>stick</i> gauche de la manette :</p>
	<ul>
		<li>créer un <code>BlendTree</code> pour l'état <code>Idle</code>,</li>
		<li>utiliser deux paramètres <code>float directionX</code>, <code>directionY</code>,</li>
		<li>paramétrer le <code>BlendTree</code> : <code>2D Simple directional</code>, et en paramètre : les deux variables,</li>
		<li>dans la liste, on va ajouter toutes les <i>motions</i> pour cet état,</li>
		<li>créer dans <code>Project</code> un dossier d’animation et un sous dossier <code>Idle</code> qui contient toutes les animations afférentes que l'on va réaliser : <i>idle_south</i>, <i>idle_est</i>...</li>
		<li>ajouter un objet dans la scène,</li>
		<li>ajouter un enfant <code>Graphics</code>, lui ajouter <code>Animator</code> comme composant,</li>
		<li>créer une animation qu’on appelle par exemple : <code>idle_south</code>,</li>
		<li>glisser dans la fenêtre <code>Animation</code> le ou les <i>sprites</i> correspondant à cet état : <code>Animation</code> présente une nouvelle propriété et une ou plusieurs <i>keyframes</i>,</li>
		<li>refaire pour toutes les orientations d’<code>Idle</code>,</li>
		<li>dans le <code>BlendTree</code>, les animations sont représentées par des points bleus, le point rouge représente la position relative aux deux variables ; on peut tout déplacer ; les dégradés représentent l’influence des animations,</li>
		<li>préférer une distribution en cercle (valeurs intermédiaires à 0.75) pour correspondre au <i>stick</i> analogique de la manette.</li>
	</ul>
</section>
<section id="event">
	<h2>Animation event</h2>
	<p>On peut déclencher des <strong>fonctions</strong> depuis l’animation, qu'on appelle <strong><i>Animation Event</i></strong>. Par exemple :</p>
	<ul>
		<li>sélectionner l’objet qui contient le composant <code>Animator</code>,</li>
		<li>dans <code>Animation</code>, sélectionner une animation,</li>
		<li>dans la <i>timeline</i>, déplacer la tête de lecture jusqu'à la fin de la séquence,</li>
		<li>cliquer sur l’icone blanche de la fenêtre en forme de tube vertical accompagné d'un <code>+</code> ; cela ajoute un petit rectangle bleu dans la <i>timeline</i> : c’est l’<code>animation event</code></li>
		<li>créer un script et l’attacher comme composant de l’objet contenant le composant <code>Animator</code>, et y écrire une fonction avec un <code>Debug.Log()</code> pour tester,</li>
		<li>ensuite, retourner dans l’<code>animation event</code> et y renseigner la fonction.</li>
	</ul>
	<p><strong>Attention</strong>, une transition s'arrêtant avant l'<code>animation event</code> ne déclenche pas ce dernier.</p>
</section>
<section id="personnage">
	<h2>Personnage</h2>
	<p>Un <strong>personnage</strong> (<i>character</i>) est un <i>mesh</i> comprenant un <strong>squelette</strong> (<i>skeleton</i>, <i>rig</i>) et éventuellement un <strong>ensemble d'animations</strong>. Exemple : un humanoïde qui marche, court, saute et salue.</p>
	<p>Le fichier importé peut ne pas être immédiatement utilisable, il convient donc d'adapter le fichier à nos besoins. Sélectionner le fichier et consulter l'<code>Inspector</code>.</p>
	<p>Onglet <code>Rig</code> : </p>
	<ul>
		<li>L'<code>Animation Type</code> détermine si le personnage est <strong>non animé</strong>, animé avec l'ancien système d'animation d'Unity (compatibilité), ou animé en tant que <strong>générique</strong> ou <strong>humanoïde</strong>. Générique/humanoïde ou bien générique/générique ne sont pas compatibles et par conséquent on ne peut pas utiliser une animation de l'un avec l'autre ; en revanche, le type humanoïde permet d'utiliser des animations d'autres humanoïdes pour celui que l'on paramètre (établissement d'une bibliothèque d'animations).</li>
		<li>En <code>Humanoid</code>, une coche à côté du bouton <code>Configure...</code> signale que le squelette est complet. Dans le cas contraire, cliquer sur le bouton pour compléter le squelette. On entre alors en édition : la <code>Scene</code> présente le <i>mesh</i>, les os, leur hiérarchie et l'<code>Inspector</code> affiche les paramètres de  l'<i>asset</i> <strong><i>avatar</i></strong>. L'<i>avatar</i> est une carte générale de l'humanoïde dont les parties réfèrent aux objets de la <code>Hierarchy</code>. Il se peut qu'il manque des références ; dans ce cas, renseigner les objets manquants. L'<i>avatar</i> présente également un onglet <code>Muscles & Settings</code> définissant comment le personnage est déformé par le squelette dans différentes poses par défaut (déplacer les <i>sliders</i> pour l'observer).</li>
	</ul>
	<p>Où trouver des animations d'humanoïdes prêts à l'emploi ? Sur le site d'<strong>Adobe Mixamo</strong> ou bien dans la suite de <i>packages</i> <strong>FBX Mocap Librairy</strong> du site d'Unity <i>AssetStore</i>.</p>
	<p>Onglets <code>Animation</code>.</p>
	<ul>
		<li>Si l'objet contient des animations, on voit ici tous leurs paramètres (exemple : boucler ou non).</li>
	</ul>
	<p>Par défaut, un personnage est en <strong><i>T pose</i></strong> ou une pose équivalente.</p>
	<p>Lors de l'import, l'objet peut avoir un composant <code>Animator</code> mais pas d'<code>Animator Controller</code> ; il faut donc créer ce dernier dans Unity et le renseigner dans le composant <code>Animator</code>.</p>
	<p>L'objet contient des animations ? Parfait. Mais il faut peut-être paramétrer le contrôleur qui, lui, est complètement vide. Pour ajouter une animation d'un personnage au contrôleur :</p>
	<ul>
		<li>dans <code>Project</code>, déplier tout dossier ou <i>asset</i> pour identifier le fichier d'animation,</li>
		<li>cliquer-déplacer l'animation dans la fenêtre <code>Animator</code>, ce qui y ajoute l'état correspondant.</li>
	</ul>
</section>
<section id="timeline">
	<h2>Timeline</h2>
	<p><strong><i>Timeline</i></strong> est un module complémentaire d'animation.</p>
	<ul>
		<li>Créer un <code>GameObject</code> et le nommer "MaSequence".</li>
		<li>Ouvrir <code>Windows > Sequencing > Timeline</code>.</li>
		<li>Cliquer sur <code>Create</code>.</li>
		<li>Nommer et enregistrer le fichier dans le répertoire des <i>assets</i>.</li>
		<li>La fenêtre affiche maintenant deux parties : à gauche : le type de pistes (<i>track</i>), à droite : la <i>timeline</i>. Un composant <code>Playable Director</code> a aussi été ajouté automatiquement à l'objet avec quelques paramètres (boucle, démarrage à <code>Awake</code>...).</li>
	</ul>
	<p>Pour animer un objet, cliquer sur le bouton <code>+</code> de la fenêtre <code>Timeline</code> et choisir <code>Animation Track</code>. Ceci permet d'animer un objet à partir de son composant <code>Animator</code> (ce composant sera ajouté si l'objet n'en a pas déjà). Glisser dans le champ nouvellement apparu l'objet de la <code>Scene</code> que l'on veut animer, par exemple un personnage.</p>
	<p>Maintenant, dans la partie de droite, glisser un <i>asset</i> d'animation, par exemple l'animation <i>Idle</i> du personnage ; à sa suite, ajouter l'animation <i>Walk</i> ; etc. De la sorte, on définit une séquence d'animations pour cet objet sur la base des animations dont il dispose.</p>
	<p>Chaque bloc est <strong>déplaçable</strong>. Chaque bloc est aussi <strong>redimensionnable</strong> de façon à jouer l'animation en boucle (si paramétrée de la sorte dans l'<i>asset</i>). Les blocs sont <strong>superposables</strong> de façon à générer une transition entre les animations. Enfin, chaque bloc expose des paramètres en <code>Inspector</code>.</p>
	<p>Une piste peut être <strong>réécrite>/strong>. Cliquer sur le bouton "3 points" de la piste et sélectionner <code>Add Override Track</code>. Puis éditer la séquence à notre convenance, par exemple en utilisant le bouton "rond rouge" qui sert à enregistrer des paramètres d'éditeur en une <i>keyframe</i>. Particularité : si on utilise une animation présentant également la <strong>translation</strong> (par exemple, le personnage qui marche se déplace vers l'avant sur une certaine distance), alors la piste de réécriture <strong>annule</strong> le déplacement, ce qui permet de paramétrer librement le déplacement, la rotation.</p>
	<p>La piste de réécriture peut enfin être <strong>convertie en séquence normale</strong> pour ensuite pouvoir être manipulée en déplacement, redimension et superposition. Pour cela, clic droit sur la séquence de la piste puis choisir <code>Convert To Clip Track</code>. Cette opération n'est pas nécessaire mais peut être utile en cas de réutilisation ou pour simplement harmoniser la <i>timeline</i>.</p>
	<p>Les <i>keyframes</i> ne sont pas éditables directement comme dans la fenêtre <code>Animation</code>. Ici, il faut d'abord cliquer sur l'icone "courbes" pour afficher la représentation en courbes de Bézier, puis sélectionner les <i>keyframes</i> et les déplacer.</p>
</section>
<footer>
	<p>Le 10-10-2021</p>
</footer>
<script src="../../js/testParent.js"></script>
