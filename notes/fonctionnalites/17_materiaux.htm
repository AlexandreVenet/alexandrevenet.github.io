<section>
	<h1>Matériaux</h1>
	<div class="blocSommaire">
		<p>Sommaire</p>
		<ol id="sommaire">
			<li><a href="#presentation">Présentation</a></li>
			<li><a href="#definir">Définir un shader</a></li>
			<li><a href="#proprietes">Propriétés</a></li>
			<li><a href="#texture">Texture</a></li>
			<li><a href="#adb">Albedo/diffuse/base map</a></li>
			<li><a href="#relief">Relief</a></li>
			<li><a href="#carteuv">Carte UV</a></li>
			<li><a href="#mipmap">Mip map</a></li>
			<li><a href="#displacement">Displacement map</a></li>
			<li><a href="#tesselation">Tesselation</a></li>
			<li><a href="#multimat">Multi-matériaux</a></li>
			<li><a href="#reflexif">Matériau réflexif</a></li>
			<li><a href="#incompatibilite">Incompatibilité</a></li>
		</ol>
	</div>
</section>
<section>
	<h2>Références</h2>
	<a class="lien" title="Manual : shaders" target="_blank" href="https://docs.unity3d.com/Manual/Shaders.html">Manual : shaders</a>
	<a class="lien" title="Manual : rendering mode" target="_blank" href="https://docs.unity3d.com/Manual/StandardShaderMaterialParameterRenderingMode.html">Manual : rendering mode</a>
	<a class="lien" title="Manual : smoothness" target="_blank" href="https://docs.unity3d.com/Manual/StandardShaderMaterialParameterSmoothness.html">Manual : smoothness</a>
	<a class="lien" title="Manual : standard shader material charts" target="_blank" href="https://docs.unity3d.com/Manual/StandardShaderMaterialCharts.html">Manual : standard shader material charts</a>
	<a class="lien" title="Wikipedia : graphics pipeline" target="_blank" href="https://en.wikipedia.org/wiki/Graphics_pipeline">Wikipedia : graphics pipeline</a>
</section>
<section id="presentation">
	<h2>Présentation</h2>
	<p>Un <i><strong>shader</strong></i> est un programme exécuté par le <strong><i>GPU (Graphics Processing Unit)</i>, le processeur graphique</strong>.</p>
	<p>Il existe plusieurs type de <i>shaders</i> :</p>
	<ul>
		<li><i><strong>common shaders</strong></i> : ils font partie du <strong><i>pipeline</i> graphique</strong> et effectuent des calculs déterminant la couleur des pixels à l'écran. Ils dépendent du <i>render pipeline</i> choisi. Dans Unity, chacun de ces <i>shaders</i> est une <strong>classe</strong> et, pour fonctionner, cette classe fait l'objet d'<strong>instanciation en un <i>Shader object</i></strong>,</li>
		<li><i><strong>compute shaders</strong></i> : ils sont en dehors du <i>pipeline</i> graphique,</li>
		<li><i><strong>raycasting</strong></i> : ils effectuent des calculs pour le lancer de rayon.</li>
	</ul>
	<p>Le <strong>matériau</strong> est une classe qui contient une <strong>référence au <i>Shader object</i></strong>. Ainsi, le <i>shader</i> détermine le matériau. Si ce <i>shader object</i> définit des propriétés de matière, de surface, alors le matériau peut contenir aussi des données comme les couleurs ou les textures.</p>
	<p>Un matériau présente des <strong>canaux</strong> (l'<i>albedo/diffuse</i> par exemple). Plus un matériau a de canaux, plus il demande de calculs. On peut réaliser des matériaux différents pour un seul <i>shader</i> (miroir, plastique...), ceci parce qu'on utilise des canaux différents avec des valeurs différentes selon les besoins (rendu, optimisation).</p>
	<p>Il existe une multitude de <i>shaders</i> dans Unity ou ailleurs ; on peut aussi en créer soi-même. Les <i>shaders</i> sont des scripts, on peut les éditer.</p>
	<p>Les <strong>matériaux</strong> prennent la forme d'<i>assets</i> (<code>.mat</code>). On peut dire qu'ils définissent les <strong>propriétés de surface</strong> des objets de façon à afficher le contenu de la scène à l'écran.</p>
</section>
<section id="definir">
	<h2>Définir un shader</h2>
	<p>Un <i>shader</i> peut être créé dans la fenêtre <code>Project</code> avec clic droit puis <code>Create &gt; Shader &gt;</code>. Cela ajoute un type de <i>shader</i> que l'on peut choisir par la suite pour nos matériaux. Les fichiers des <i>shaders</i> graphiques sont de deux types dans Unity :</p>
	<ul>
		<li>en code : <i><strong>shaderLab</strong></i> pour le <i>built-in render pipeline</i>,</li>
		<li>en gestion nodale : <i><strong>ShaderGraph</strong></i> pour <i>URP</i> ou <i>HDRP</i>.</li>
	</ul>
</section>
<section id="proprietes">
	<h2>Propriétés</h2>
	<p>Voyons quelques propriétés communes qu'on peut trouver dans un matériau.</p>
	<p><code>Rendering mode</code> :</p>
	<ul>
		<li><code>Opaque</code> : l'objet ne laisse pas traverser la lumière,</li>
		<li><code>Transparent</code> : l'objet laisse traverser la lumièren et il a une couleur (plastique, verre),</li>
		<li><code>Fade</code> : fait disparaître un objet progressivement (ne sert pas à rendre une matière d’objet),</li>
	 <li><code>Cutout</code> : affiche/masque des zones de la textures (noir invisible, blanc visible).</li>
	</ul>
	<p>L'<code>albédo</code> ou <code>Base map</code> définit la ou les couleurs réfléchies par la lumière. Ce peut être une couleur avec ou non une transparence, ou une image.</p>
	<p><code>Metalic</code> définit comment l'objet est métallique. <code>Smoothness</code> détermine si l'objet est rugueux ou lisse et influence l'impact de lumière (<i>specular</i>). Par exemple, un miroir parfait présente 100% aux deux paramètres.</p>
	<p><code>Mask Map</code> permet d'insérer une image définissant pour l'objet les zones métalliques ou lisses.</p>
	<p><code>Specular highlights</code> définit l'impact de lumière.</p>
	p><code>Reflections</code> concerne le réfléchissement de l'environnement. Par exemple : l'herbe ne réfléchit pas l'environnement, le métal réfléchit l'environnement.</p>
	<p><code>Tiling</code> permet de répéter la texture sur la surface.</p>
	<p><code>Offset</code> permet d'effectuer un décalage de la texture par rapport à a son point d'origine sur la surface.</p>
	<p>Dans Unity, un bouton <code>Edit</code> de l'<code>Inspector</code> permet d'éditer le <i>shader</i> du matériau sélectionné.</p>
</section>
<section id="texture">
	<h2>Texture</h2>
	<p>Une <strong>texture</strong> peut être paramétrée de bien des façons (<i>sprite</i> 2D par exemple). Il existe un type avancé qui propose quantités d'options n'apparaissant pas nécessairement sous d'autres types. Donc, les paramètres d'importation influencent l'usage de la texture, par exemple dans les matériaux.</p>
</section>
<section id="adb">
	<h2>Albedo/diffuse/base map</h2>
	<p>L'albedo ou le <i>diffuse</i> ou encore la <i>base map</i> peut accueillir une couleur avec prise en charge de la transparence, ou une texture qui gère les deux. Cela projette une image <strong>à plat</strong> sur la surface.</p>
</section>
<section id="relief">
	<h2>Relief</h2>
	<p>La <i><strong>normal map</strong></i> est une texture <strong>simulant un relief</strong> sous l'effet de la lumière, sans complexifier le <i>mesh</i>.</p>
	<p>Il existe 2 types de textures pour simuler le relief :</p>
	<ul>
		<li><i><strong>bump map</strong></i> : texture en niveau de gris,</li>
		<li><i><strong>normal map</strong></i> : image en RVB représentant l'orientation de la mini-facette du pixel à l'aide de 3 axes x, y, z représentés par les composantes r, v, b. On la génère en général à partir d'un <i>mesh</i> de haute définition (3dSMAx, Maya, Blender) ; on peut aussi la réaliser à la main dans un éditeur photo, ou par code. Voir le <code>Texture Type</code> dans les paramètres de la texture importée.</li>
	</ul>
	<p>Les fichiers de ce genre peuvent être enregistrés en TIFF.</p>
	<p>Côté matériau, la <i>normal map</i> peut ne pas être prise en charge. Le matériau <i><strong>Bumped diffuse</strong></i> présente ce paramètre. L'importance du relief (<i>bumpiness</i>) se définit soit dans les paramètres de la texture, soit dans les paramètres du matériau.</p>
	<p>Astuce : une <i>normal map</i> peut être généré à partir d'une texture utilisée pour le canal <i>diffuse</i>/<i>albedo</i>.</p>
	<ul>
		<li>Sélectionner la texture.</li>
		<li>La dupliquer avec <code>CTRL + D</code>.</li>
		<li>Changer le <code>Texture Type</code> à <code>Normal Map</code>.</li>
		<li>Cocher la case <code>Create from Gayscale</code>. Définir les paramètres <code>Bumpiness</code> et <code>Filtering</code> selon les besoins.</li>
		<li>Cliquer sur le bouton <code>Apply</code>.</li>
	</ul>
	<p>Créer des <i>normal maps</i> avec <a href="http://www.crazybump.com">http://www.crazybump.com</a>. Conseil proposé :</p>
	<ul>
		<li>éditer une <i>bump map</i> dans un éditeur graphique,</li>
		<li>l'utiliser comme base de travail dans CrazyBump pour générer la <i>normal map</i>.</li>
	</ul>
</section>
<section id="carteuv">
	<h2>Carte UV</h2>
	<p>Une carte UV est un <strong>dépliage 2D</strong> du <i>mesh</i>. On l'utilise pour dessiner la texture.</p>
	<p>Pour l'optimiser :</p>
	<ul>
		<li>réduire les espaces vides,</li>
		<li>superposer les éléments qui se répètent à l'identique (on n'en dessinera qu'un seul pour tous),</li>
		<li>penser la taille de sortie (plus c'est grand, plus il y a de détails),</li>
		<li>l'espace doit être (0,1),</li>
		<li>les formes doivent être proportionnées exactement comme l'objet final.</li>
	</ul>
</section>
<section id="mipmap">
	<h2>Mip map</h2>
	<p>La texture prend de la mémoire pour être calculée à l'écran. Or, lorsque la caméra est loin de l'objet, elle n'affiche pas autant de détails que si elle est près de l'objet. Il existe un moyen de réduire ce niveau de détails selon la distance de la caméra à l'objet. Ce sont les <i><strong>mip maps</strong></i>.</p>
	<p>Dans les options de la fenêtre <code>Scene</code>, on peut afficher les informations de texture et en particulier les <i>mip maps</i>. Une texture apparaît en rouge lorsqu'elle est trop grande par rapport à la distance de la caméra (il y a trop d'informations pour cette distance).</p>
</section>
<section id="displacement">
	<h2>Displacement map</h2>
	<p>Choisir un <i>shader</i> <code>Parallax diffuse</code>.</p>
	<ul>
		<li><strong>Heightmap (A)</strong> : carte de hauteur selon le canal de transparence.</li>
	</ul>
	<p>On réalise cela aussi avec CrazyBump : créer une <i>normal map</i> et une <i>displacement map</i>.</p>
	<p>Ensuite, dans Unity :</p>
	<ul>
		<li>importer la <i>normal map</i> en tant que <code>Normal map</code>,</li>
		<li>et la <i>displacement map</i> en tant que <code>Texture</code>. Cocher la case <code>Alpha from grayscale</code> de façon à correspondre à ce qui est attendu dans le <i>shader</i>.</li>
	</ul>
	<p>La <i>displacement map</i> produit alors un effet de déformation mais il est relatif à la caméra. Exemple d'utilisation : trou d'impact de missile dans Fallout 4. Limitation : plus la caméra s'aligne sur la surface, plus l'effet est incompréhensible.</p>
</section>
<section id="tesselation">
	<h2>Tesselation</h2>
	<p>La <strong>tesselation</strong> n'est disponible qu'avec DirectX 11.</p>
	<ul>
		<li>Cela fait l'objet d'un <i>package</i> spécifique à installer : <strong>Tesselation shaders</strong>.</li>
		<li>Unity doit fonctionner aussi en DirectX 11 pour prendre en charge cet effet. Menu <code>Edit &gt; Project settings... &gt; Player</code> puis les paramètres PC/Mac/Linux et la propriété <strong>Use Direct3D 11</strong>.</li>
	</ul>
	<p>Le <i>shader</i> à utiliser est <strong>Bumped specular (dislacement)</strong>.</p>
	<p>Alors, le <i>mesh</i> est <strong>automatiquement subdivisé</strong> et déformé. Ceci dépend des paramètres renseignés mais aussi de la <strong>distance de la caméra</strong>.</p>
	<p>Pour optimiser :</p>
	<ul>
		<li>diviser l'objet en autant de parties nécessaires pour lesquelles appliquer la tesselation (là où ce n'est pas nécessaire, le calcul n'a pas lieu et le <i>shader</i> peut être plus simple),</li>
		<li>penser la carte UV selon la tesselation sinon il peut y avoir des abérations (là où il a des bords dans la carte UV, colorer en noir sinon cela fera des trous dans le <i>mesh</i>, le noir signifiant pas de transformation),</li>
		<li>le maillage doit être uniforme (pas de polygones étirés).</li>
	</ul>
</section>
<section id="multimat">
	<h2>Multi-matériaux</h2>
	<p>Les matériaux s'utilisent en général dans un <code>Mesh Renderer</code>. Et, en général toujours, un <code>Mesh Renderer</code> présente un matériau (sinon, Unity affiche l'objet en magenta très agréable pour les yeux).</p>
	<p>On peut créer un objet qui possède plusieurs matériaux. Cela est plus lourd qu'un seul, certes, mais présente des avantages. Par exmeple, lorsque la caméra est loin de l'objet, la texture qui sera affichée correspondra à la distance séparant la caméra de l'objet (les plus détaillées, c'est-à-dire les plus grandes, feront l'objet de <i>mip map</i>).</p>
	<p>Donc, il s'agit de créer aussi autant de cartes UV que de &quot;couches&quot; de matériau à utiliser. Exemple : si on veut utiliser 4 matériaux, alors il faut créer 4 cartes UV différentes et le graphiste édite ces textures une par une.</p>
</section>
<section id="reflexif">
	<h2>Matériau réflexif</h2>
	<p>Il existe un <i>shader</i> de type réflexif pour donner à un matériau une certaine réflexion (et pas seulement le <i>skybox</i> de la scène). Ceci s'effectue à l'aide d'une <i>cube map</i>. Donc :</p>
	<ul>
		<li>créer une <i>cube map</i> (clic droit dans <code>Project</code>),</li>
		<li>créer le matériau de type réflexif.</li>
	</ul>
	<p>Pour créer un matériau réflexif temps réel :</p>
	<ul>
		<li>poser une caméra quelque part,</li>
		<li>créer dans <code>Project</code> une <strong>Render texture</strong>,</li>
		<li>dans la caméra, propriété <strong>Target texture</strong>, renseigner la texture précédente,</li>
		<li>créer par exemple un plan et y mettre un matériau de type réflexif (ou présentant un paramètre de réflexion) et dans le paramètre de réflexion lui renseigner cette <i>render texture</i>.</li>
	</ul>
</section>
<section id="incompatibilite">
	<h2>Incompatibilité</h2>
	<p>Des problèmes de compatibilité peuvent se poser lorsqu'un <i>mesh</i> est importé dans un projet UPR/HDRP. En effet, les matériaux peuvent ne pas correspondre aux paramètres d'Unity.</p>
	<p>Dans ce cas, les matériaux (et donc les objets les utilisant) apparaissent en aplat de couleur magenta toujours agréable pour les yeux.</p>
	<p>Pour changer cela, sélectionner le matériau et suivre deux methodes :</p>
	<ul>
		<li><strong>automatique</strong> : sélectionner le matériau, puis menu <code>Edit &gt; Render pipeline &gt; Upgrade Selected Materials to High Definition Materials</code>. Mais cela peut ne pas fonctionner alors on passera en...</li>
		<li><strong>manuel</strong> : sélectionner le matériau et sélectionner un <code>Shader</code> de type URP ou HDRP. Alors, certaines références de textures (par exemple dans <code>albedo</code> ou <code>Base map</code>) peuvent avoir été supprimées et il faut alors les réassigner.</li>
	</ul>
</section>
<footer>
	<p>Le 31-10-2021</p>
</footer>
<script src="../../js/testParent.js"></script>
